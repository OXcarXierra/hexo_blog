---
title: 백준 1931 회의실 배정
tags: [greedy algorithm]
categories: [Algorithm]
thumbnail: ''
permalink: ''
date: 2022-07-16 17:27:45
---

Greedy Algorithm (탐욕법)의 간단한 공부와 회의실 배정 문제

<!-- excerpt -->

## Greedy Algorithm

탐욕적 알고리즘(그리디 알고리즘)이 사용되는 경우는 두 가지가 있다.

1. 탐욕법을 사용해도 항상 최적해를 구할 수 있는 문제
2. 다른 방법으로 최적해를 찾기 너무 어려울 때 근사해를 구할 수 있음.

탐욕적 알고리즘으로 찾은 해가 항상 최적해라는 정당성을 증명하려면

1. 탐욕적으로만 선택하더라도 최적해를 구할 수 있다는 것. 즉, 적어도 하나의 최적해는 이 알고리즘으로 구할 수 있다는 것.(탐욕적 선택 속성, greedy choice property)
2. 항상 최적의 선택만을 내려서 전체 문제의 최적해를 얻을 수 있음을 증명. (최적 부분 구조, optimal substructure) ⇒ 대부분은 자명

### 문제

한 개의 회의실이 있는데 이를 사용하고자 하는 N개의 회의에 대하여 회의실 사용표를 만들려고 한다. 각 회의 I에 대해 시작시간과 끝나는 시간이 주어져 있고, 각 회의가 겹치지 않게 하면서 회의실을 사용할 수 있는 회의의 최대 개수를 찾아보자. 단, 회의는 한번 시작하면 중간에 중단될 수 없으며 한 회의가 끝나는 것과 동시에 다음 회의가 시작될 수 있다. 회의의 시작시간과 끝나는 시간이 같을 수도 있다. 이 경우에는 시작하자마자 끝나는 것으로 생각하면 된다.

### 풀이

초기 시도: 재귀, 분할정복을 이용해보았지만 시간초과.

```python
def greedy():
  global cnt, time
  time_min = time[0]
  new_time=[]
  for i in time:
    if not time_min[1]<=i[0]:
      new_time.append(i)
  time=new_time
  print(time)
  cnt += 1
  if time:
    greedy()
  else:
    print(cnt)

greedy()
```

탐욕법 이용:

```python
import sys
N = int(sys.stdin.readline())
time = [list(map(int, sys.stdin.readline().split())) for _ in range(N)]
cnt = 1
time.sort(key=lambda t: (t[1],t[0]))
end_time = time[0][1]
for i in range(1,N):
  if time[i][0] >= end_time:
    cnt += 1
    end_time=time[i][1]
print(cnt)
```
